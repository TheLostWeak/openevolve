You are to produce or improve a complete, runnable Python module that
constructs a large cap set in F_3^n using ONE fixed algorithmic structure.

IMPORTANT:
- The evaluator will call generate_set(8) exactly once.
- Internal parameter tuning (e.g. Optuna) is allowed and encouraged.
- Algorithmic structure MUST remain invariant across all trials.

────────────────────────────────────────────────────────────
PROBLEM
────────────────────────────────────────────────────────────

A cap set is a subset A of F_3^n such that there are no three distinct
elements x, y, z in A with x + y + z ≡ 0 (mod 3) coordinate-wise.

Your goal is to maximize |A|. Correctness is mandatory.

────────────────────────────────────────────────────────────
CRITICAL DESIGN CONSTRAINTS (DO NOT VIOLATE)
────────────────────────────────────────────────────────────

1. EXACTLY ONE algorithmic strategy.
   - Do NOT switch between different construction paradigms.
   - Do NOT introduce strategy-selection flags or categorical choices.
   - Control flow and data structures must be identical in all runs.

2. All tunable parameters MUST have stable semantics.
   - Parameters may affect:
       • scoring weights
       • probabilities / noise levels
       • thresholds / limits
       • iteration counts
   - Parameters MUST NOT:
       • enable/disable large code paths
       • select different algorithms
       • change data representations

3. If parameter tuning is used (e.g. Optuna):
   - Trials MUST optimize the SAME objective function f(params).
   - Prefer fewer parameters (≈4–7) with smooth influence.
   - Prefer multi-seed averaging inside the objective to reduce noise.

────────────────────────────────────────────────────────────
STRUCTURE GUIDANCE (SOFT, NOT MANDATORY)
────────────────────────────────────────────────────────────

Good constructions typically involve:
- A structured deterministic seed (e.g. product or symmetric construction)
- Incremental greedy growth under a scoring heuristic
- Limited local repair or swap-based augmentation
- Strong determinism (fixed seeds, bounded runtime)

Favor:
- Strong initial structure + soft stochastic refinement
- Local improvements over global rewrites

Avoid:
- Large explicit enumerations
- Full backtracking over F_3^8
- Unbounded or super-exponential search

────────────────────────────────────────────────────────────
API REQUIREMENTS
────────────────────────────────────────────────────────────

The module MUST define:

    def generate_set(n: int) -> List[Tuple[int, ...]]

- The evaluator will call generate_set(8).
- The function must always return a valid cap set.
- Runtime must be bounded and predictable.

Encapsulate the construction in a class, e.g.:

    class CapSetBuilder:
        def __init__(self, params, seed):
            ...
        def build(self) -> List[int]:
            ...

────────────────────────────────────────────────────────────
DETERMINISM
────────────────────────────────────────────────────────────

- Define a module-level constant _RANDOM_SEED.
- Seed all RNGs deterministically.
- Given identical parameters, output must be reproducible.

────────────────────────────────────────────────────────────
DOCUMENTATION (LIGHTWEIGHT)
────────────────────────────────────────────────────────────

At the top of the file, briefly describe:
- The fixed algorithmic idea
- The meaning of each tunable parameter

Do NOT include external references or excessive explanation.

────────────────────────────────────────────────────────────
OUTPUT FORMAT
────────────────────────────────────────────────────────────

Return ONLY a complete Python module enclosed in:

```python
<full module text>
````