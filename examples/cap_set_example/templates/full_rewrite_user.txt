
# TASK SPECIFICATION (SIMPLIFIED, FINAL VERSION)

You must produce a **complete, runnable Python module** that constructs a large **cap set** in  
ð”½â‚ƒâ¿ using **one fixed algorithmic structure**.

---

## 1. Problem Definition

A **cap set** is a subset A âŠ† ð”½â‚ƒâ¿ such that there exist **no three distinct elements**
x, y, z âˆˆ A satisfying:

    x + y + z â‰¡ 0 (mod 3)

The goal is to **maximize |A|**, while guaranteeing correctness.

---

## 2. Evaluation Constraints

- The evaluator will call **`generate_set(8)` exactly once**.
- Runtime must be bounded and predictable.
- Output must always be a valid cap set.

---

## 3. Mandatory Algorithmic Structure (Strict)

You must use **one single, fixed greedy algorithm** with the following structure:

1. Start from the empty set.
2. **Before construction**, compute a priority score for *every* candidate point.
   - The score must depend **only on intrinsic properties** of the point.
3. Sort all candidates **once** by this score (descending).
4. Iterate through the sorted list:
   - Add a point if doing so preserves the cap-set property.
   - Otherwise skip it.
5. Return the final set.

### Absolute Invariant

> The global ordering of candidates is computed **once** and never changed.
> No dynamic reordering or adaptive behavior is allowed.

---



## 4. Mandatory Use of Optuna

Inside `generate_set`, you **must**:

1. Run an Optuna study using `TPESampler`.
2. Optimize parameters that affect only the scoring function.
3. Use the best parameters to perform **one final construction**.
4. Return the resulting cap set.

Constraints:
- All trials must run the same algorithm.
- No structural changes per trial.
- Recommended:
  - `max_trials â‰ˆ 300`
  - `timeout â‰¥ 180 seconds`

---

## 5. Required API

Your module must define:

```python
def generate_set(n: int) -> List[Tuple[int, ...]]:
````

You may optionally structure code as:

```python
class CapSetBuilder:
    def __init__(self, params, seed):
        ...
    def build(self) -> List[Tuple[int, ...]]:
        ...
```

---

## 6. Determinism

* Define a module-level `_RANDOM_SEED`
* Seed all randomness from it
* Identical parameters must always produce identical output

---

## 7. Minimal Documentation

At the top of the file, briefly describe:

* The fixed greedy algorithm
* The meaning of each tunable parameter

No extra commentary or references.

---

## 8. Output Format

Return **only** a complete Python module:

```python
<full module code>
```

## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

## CURRENT PROGRAM CONTEXT (FILLED BY SYSTEM)

## â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Parent program code (base to improve):
```python
{current_program}
```

Metrics / fitness:
- {metrics}
- fitness_score: {fitness_score}
- feature_coords: {feature_coords}

Recent evolution highlights:
{improvement_areas}

Top/diverse attempts from this island:
{evolution_history}

Inspirations (same island):
{inspirations}

Artifacts (if available):
{artifacts}
