=== System Prompt ===

You are an expert software developer tasked with iteratively improving a codebase.
Your goal is to maximize the FITNESS SCORE while exploring diverse solutions across feature dimensions.
The system maintains a collection of diverse programs - both high fitness AND diversity are valuable.

=== User Prompt ===

# Task Specification (Diff Mode)
Goal: improve the cap-set generator while keeping a single, greedy, priority-driven algorithm that grows a cap set in (F3^n) by adding points in descending priority order and skipping any that break the cap-set constraint.

Critical rules:
- Exactly one algorithmic structure; no mode switches, backtracking, swaps, or alternate strategies.
- Start from the empty set, score all candidates, add valid points in priority order, stop when no candidate can be added.
- Parameters may only tune scoring weights, smooth noise/tie-breaking, thresholds, or iteration counts; they must not alter control flow or data representation.
- Optuna with `TPESampler` must run inside `generate_set` first, then the best params must drive one deterministic construction whose result is returned.
- API: `def generate_set(n: int) -> List[Tuple[int, ...]]` (the evaluator will call `generate_set(8)`).
- Determinism: define `_RANDOM_SEED` and seed all RNGs so identical params yield identical output.
- Keep a brief header comment explaining the fixed idea and the meaning of each tunable parameter.

# Current Program Status
- Fitness: 0.0000
- Feature coordinates: combined_score=0.00
- Metrics:
- combined_score: 0.0000
- error: generator failure
- error_detail: Optuna is not installed. Please run: pip install optuna
- eval_time_seconds: 0.0775
- dimension: 8.0000
- traceback: Traceback (most recent call last):
  File "C:\Users\admin\AppData\Local\Temp\openevolve_gen_runner_gj67l7ah.py", line 18, in <module>
    res = mod.generate_set(arg)
  File "C:\Users\admin\AppData\Local\Temp	mpv8ch1ym8.py", line 163, in generate_set
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
  File "C:\Users\admin\AppData\Local\Temp	mpv8ch1ym8.py", line 138, in tune_with_optuna
    raise RuntimeError("Optuna is not installed. Please run: pip install optuna")
RuntimeError: Optuna is not installed. Please run: pip install optuna

- artifact_path: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_7e313a5d_tmpv8ch1ym8.py
- generator_stdout_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_b389a90c_generator_stdout.json
- generator_stderr_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_b389a90c_generator_stderr.txt
- Areas identified for improvement:
- Fitness unchanged at 0.0000
- Exploring combined_score=0.00 region of solution space



# Program Evolution History
## Previous Attempts

### Attempt 3
- Changes: Change 1: 'CAP_N = 6' to 'CAP_N = 8'
Change 2: Replace 4 lines with 4 lines
- Metrics: combined_score: 0.0000, error: generator failure, error_detail: Optuna is not installed. Please run: pip install optuna, eval_time_seconds: 0.0879, dimension: 8.0000, traceback: Traceback (most recent call last):
  File "C:\Users\admin\AppData\Local\Temp\openevolve_gen_runner_gcnwiz_q.py", line 18, in <module>
    res = mod.generate_set(arg)
  File "C:\Users\admin\AppData\Local\Temp	mpuh9yf4pn.py", line 163, in generate_set
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
  File "C:\Users\admin\AppData\Local\Temp	mpuh9yf4pn.py", line 138, in tune_with_optuna
    raise RuntimeError("Optuna is not installed. Please run: pip install optuna")
RuntimeError: Optuna is not installed. Please run: pip install optuna
, artifact_path: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020451Z_307e6521_tmpuh9yf4pn.py, generator_stdout_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020452Z_d9c70760_generator_stdout.json, generator_stderr_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020452Z_d9c70760_generator_stderr.txt
- Outcome: Mixed results

### Attempt 2
- Changes: Unknown changes
- Metrics: combined_score: 0.0000, error: generator failure, error_detail: Optuna is not installed. Please run: pip install optuna, eval_time_seconds: 0.0775, dimension: 8.0000, traceback: Traceback (most recent call last):
  File "C:\Users\admin\AppData\Local\Temp\openevolve_gen_runner_gj67l7ah.py", line 18, in <module>
    res = mod.generate_set(arg)
  File "C:\Users\admin\AppData\Local\Temp	mpv8ch1ym8.py", line 163, in generate_set
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
  File "C:\Users\admin\AppData\Local\Temp	mpv8ch1ym8.py", line 138, in tune_with_optuna
    raise RuntimeError("Optuna is not installed. Please run: pip install optuna")
RuntimeError: Optuna is not installed. Please run: pip install optuna
, artifact_path: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_7e313a5d_tmpv8ch1ym8.py, generator_stdout_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_b389a90c_generator_stdout.json, generator_stderr_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_b389a90c_generator_stderr.txt
- Outcome: Mixed results

### Attempt 1
- Changes: Change 1: 'CAP_N = 6' to 'CAP_N = 8'
Change 2: Replace 4 lines with 11 lines
Change 3: Replace 23 lines with 35 lines
Change 4: Replace 9 lines with 10 lines
Change 5: Replace 22 lines with 23 lines
- Metrics: combined_score: 265.0000, size: 265.0000, valid: 1.0000, eval_time_seconds: 134.4474, dimension: 8.0000, artifact_path: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020157Z_63b3a0e3_tmpqtdfj3hr.py, generator_stdout_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020411Z_f81f7a10_generator_stdout.json, generator_stderr_artifact: C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020411Z_f81f7a10_generator_stderr.txt
- Outcome: Mixed results

## Top Performing Programs

### Program 1 (Score: 265.0000)
```python
import itertools
import random
from typing import Tuple, List, Optional, Dict, Any, Set

CAP_N = 8
_RANDOM_SEED = 42


def can_add(
    new_vec: Tuple[int, ...],
    existing_list: List[Tuple[int, ...]],
    existing_set: Optional[set] = None,
) -> bool:
    if existing_set is None:
        existing_set = set(existing_list)

    if new_vec in existing_set:
        return False

    for x in existing_list:
        y = tuple((-(a + b)) % 3 for a, b in zip(x, new_vec))
        if y in existing_set and y != x:
            return False

    return True


class GreedyCapSetGenerator:
    def __init__(self, n: int = CAP_N, params: Optional[Dict[str, Any]] = None):
        self.n = n
        self.params: Dict[str, Any] = {
            "balance_weight": 0.6,
            "existing_penalty": 0.1,
            "random_noise": 0.02,
            "diversity_weight": 0.3,
        }
        if params:
            self.params.update(params)

    @staticmethod
    def _try_import_optuna():
        try:
            import optuna  # type: ignore
        except ImportError:
            return None
        return optuna

    def _compute_priorities(
        self,
        candidates: List[Tuple[int, ...]],
        capset: List[Tuple[int, ...]],
        params: Dict[str, Any],
        rng: random.Random,
    ) -> Dict[Tuple[int, ...], float]:
        """
        每轮只调用一次：把 candidates 中所有点的 priority 一次性算完并返回。
        逻辑保持示范级简单：
        - imbalance（点自身）
        - existing_penalty * len(capset)（与已选集合的最弱耦合）
        - 微噪声用于打平（可选）
        """
        priorities: Dict[Tuple[int, ...], float] = {}

        existing_term = params["existing_penalty"] * len(capset)
        noise = params.get("random_noise", 0.0)
        bw = params["balance_weight"]

        for vec in candidates:
            c0 = vec.count(0)
            c1 = vec.count(1)
            c2 = vec.count(2)
            imbalance = abs(c0 - c1) + abs(c1 - c2) + abs(c0 - c2)

            score = -bw * imbalance - existing_term
            if noise:
                score += noise * rng.random()

            priorities[vec] = score

        return priorities

    def generate(
        self,
        params: Optional[Dict[str, Any]] = None,
        rng: Optional[random.Random] = None,
    ) -> List[Tuple[int, ...]]:
        if rng is None:
            rng = random.Random(_RANDOM_SEED)

        active_params = dict(self.params)
        if params:
            active_params.update(params)

        all_vectors = list(itertools.product([0, 1, 2], repeat=self.n))

        capset: List[Tuple[int, ...]] = []
        capset_set: Set[Tuple[int, ...]] = set()

        # 动态贪心：每次选点后，重新计算所有候选点的 priority（但每轮只调用一次计算函数）
        while True:
            # 先收集本轮“可加入”的候选点
            candidates: List[Tuple[int, ...]] = []
            for vec in all_vectors:
                if vec in capset_set:
                    continue
                if can_add(vec, capset, capset_set):
                    candidates.append(vec)

            if not candidates:
                break

            # 每轮只调用一次：批量计算 priority
            priorities = self._compute_priorities(candidates, capset, active_params, rng)

            # 再遍历取最大
            best_vec = None
            best_score = float("-inf")
            for vec in candidates:
                s = priorities[vec]
                if s > best_score:
                    best_score = s
                    best_vec = vec

            if best_vec is None:
                break

            capset.append(best_vec)
            capset_set.add(best_vec)

        return capset

    def tune_with_optuna(
        self,
        max_trials: int = 20,
        timeout: float = 30.0,
    ) -> Tuple[Dict[str, Any], List[Tuple[int, ...]]]:
        optuna = self._try_import_optuna()
        if optuna is None:
            raise RuntimeError("Optuna is not installed. Please run: pip install optuna")

        def objective(trial: Any) -> float:
            sampled = {
                "balance_weight": trial.suggest_float("balance_weight", 0.0, 2.0),
                "existing_penalty": trial.suggest_float("existing_penalty", 0.0, 1.0),
                "random_noise": trial.suggest_float("random_noise", 0.0, 0.05),
            }
            cap = self.generate(params=sampled, rng=random.Random(_RANDOM_SEED))
            return float(len(cap))

        study = optuna.create_study(
            direction="maximize",
            sampler=optuna.samplers.TPESampler(seed=_RANDOM_SEED),
        )
        study.optimize(objective, n_trials=max_trials, timeout=timeout)

        best_params = dict(self.params)
        best_params.update(study.best_params)
        best_capset = self.generate(params=best_params, rng=random.Random(_RANDOM_SEED))
        return best_params, best_capset


def generate_set(n: int) -> List[Tuple[int, ...]]:
    # Handle Optuna import gracefully
    optuna = GreedyCapSetGenerator._try_import_optuna()
    if optuna is None:
        # Fallback to default parameters if Optuna is not available
        generator = GreedyCapSetGenerator(n=n)
        return generator.generate()
    
    generator = GreedyCapSetGenerator(n=n)
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
    return tuned_capset


```
Key features: Performs well on combined_score (265.0000), Performs well on size (265.0000), Performs well on valid (1.0000), Performs well on eval_time_seconds (134.4474), Performs well on dimension (8.0000), Performs well on artifact_path (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020157Z_63b3a0e3_tmpqtdfj3hr.py), Performs well on generator_stdout_artifact (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020411Z_f81f7a10_generator_stdout.json), Performs well on generator_stderr_artifact (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020411Z_f81f7a10_generator_stderr.txt)

### Program 2 (Score: 0.0000)
```python
import itertools
import random
from typing import Tuple, List, Optional, Dict, Any, Set

CAP_N = 6
_RANDOM_SEED = 42


def can_add(
    new_vec: Tuple[int, ...],
    existing_list: List[Tuple[int, ...]],
    existing_set: Optional[set] = None,
) -> bool:
    if existing_set is None:
        existing_set = set(existing_list)

    if new_vec in existing_set:
        return False

    for x in existing_list:
        y = tuple((-(a + b)) % 3 for a, b in zip(x, new_vec))
        if y in existing_set and y != x:
            return False

    return True


class GreedyCapSetGenerator:
    def __init__(self, n: int = CAP_N, params: Optional[Dict[str, Any]] = None):
        self.n = n
        self.params: Dict[str, Any] = {
            "balance_weight": 0.6,
            "existing_penalty": 0.1,
            "random_noise": 0.02,
        }
        if params:
            self.params.update(params)

    @staticmethod
    def _try_import_optuna():
        try:
            import optuna  # type: ignore
        except ImportError:
            return None
        return optuna

    def _compute_priorities(
        self,
        candidates: List[Tuple[int, ...]],
        capset: List[Tuple[int, ...]],
        params: Dict[str, Any],
        rng: random.Random,
    ) -> Dict[Tuple[int, ...], float]:
        """
        每轮只调用一次：把 candidates 中所有点的 priority 一次性算完并返回。
        逻辑保持示范级简单：
        - imbalance（点自身）
        - existing_penalty * len(capset)（与已选集合的最弱耦合）
        - 微噪声用于打平（可选）
        """
        priorities: Dict[Tuple[int, ...], float] = {}

        existing_term = params["existing_penalty"] * len(capset)
        noise = params.get("random_noise", 0.0)
        bw = params["balance_weight"]

        for vec in candidates:
            c0 = vec.count(0)
            c1 = vec.count(1)
            c2 = vec.count(2)
            imbalance = abs(c0 - c1) + abs(c1 - c2) + abs(c0 - c2)

            score = -bw * imbalance - existing_term
            if noise:
                score += noise * rng.random()

            priorities[vec] = score

        return priorities

    def generate(
        self,
        params: Optional[Dict[str, Any]] = None,
        rng: Optional[random.Random] = None,
    ) -> List[Tuple[int, ...]]:
        if rng is None:
            rng = random.Random(_RANDOM_SEED)

        active_params = dict(self.params)
        if params:
            active_params.update(params)

        all_vectors = list(itertools.product([0, 1, 2], repeat=self.n))

        capset: List[Tuple[int, ...]] = []
        capset_set: Set[Tuple[int, ...]] = set()

        # 动态贪心：每次选点后，重新计算所有候选点的 priority（但每轮只调用一次计算函数）
        while True:
            # 先收集本轮“可加入”的候选点
            candidates: List[Tuple[int, ...]] = []
            for vec in all_vectors:
                if vec in capset_set:
                    continue
                if can_add(vec, capset, capset_set):
                    candidates.append(vec)

            if not candidates:
                break

            # 每轮只调用一次：批量计算 priority
            priorities = self._compute_priorities(candidates, capset, active_params, rng)

            # 再遍历取最大
            best_vec = None
            best_score = float("-inf")
            for vec in candidates:
                s = priorities[vec]
                if s > best_score:
                    best_score = s
                    best_vec = vec

            if best_vec is None:
                break

            capset.append(best_vec)
            capset_set.add(best_vec)

        return capset

    def tune_with_optuna(
        self,
        max_trials: int = 20,
        timeout: float = 30.0,
    ) -> Tuple[Dict[str, Any], List[Tuple[int, ...]]]:
        optuna = self._try_import_optuna()
        if optuna is None:
            raise RuntimeError("Optuna is not installed. Please run: pip install optuna")

        def objective(trial: Any) -> float:
            sampled = {
                "balance_weight": trial.suggest_float("balance_weight", 0.0, 2.0),
                "existing_penalty": trial.suggest_float("existing_penalty", 0.0, 1.0),
                "random_noise": trial.suggest_float("random_noise", 0.0, 0.05),
            }
            cap = self.generate(params=sampled, rng=random.Random(_RANDOM_SEED))
            return float(len(cap))

        study = optuna.create_study(
            direction="maximize",
            sampler=optuna.samplers.TPESampler(seed=_RANDOM_SEED),
        )
        study.optimize(objective, n_trials=max_trials, timeout=timeout)

        best_params = dict(self.params)
        best_params.update(study.best_params)
        best_capset = self.generate(params=best_params, rng=random.Random(_RANDOM_SEED))
        return best_params, best_capset


def generate_set(n: int) -> List[Tuple[int, ...]]:
    generator = GreedyCapSetGenerator(n=CAP_N)
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
    return tuned_capset


```
Key features: Performs well on combined_score (0.0000), Performs well on error (generator failure), Performs well on error_detail (Optuna is not installed. Please run: pip install optuna), Performs well on eval_time_seconds (0.0775), Performs well on dimension (8.0000), Performs well on traceback (Traceback (most recent call last):
  File "C:\Users\admin\AppData\Local\Temp\openevolve_gen_runner_gj67l7ah.py", line 18, in <module>
    res = mod.generate_set(arg)
  File "C:\Users\admin\AppData\Local\Temp	mpv8ch1ym8.py", line 163, in generate_set
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
  File "C:\Users\admin\AppData\Local\Temp	mpv8ch1ym8.py", line 138, in tune_with_optuna
    raise RuntimeError("Optuna is not installed. Please run: pip install optuna")
RuntimeError: Optuna is not installed. Please run: pip install optuna
), Performs well on artifact_path (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_7e313a5d_tmpv8ch1ym8.py), Performs well on generator_stdout_artifact (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_b389a90c_generator_stdout.json), Performs well on generator_stderr_artifact (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T015911Z_b389a90c_generator_stderr.txt)

### Program 3 (Score: 0.0000)
```python
import itertools
import random
from typing import Tuple, List, Optional, Dict, Any, Set

CAP_N = 8
_RANDOM_SEED = 42


def can_add(
    new_vec: Tuple[int, ...],
    existing_list: List[Tuple[int, ...]],
    existing_set: Optional[set] = None,
) -> bool:
    if existing_set is None:
        existing_set = set(existing_list)

    if new_vec in existing_set:
        return False

    for x in existing_list:
        y = tuple((-(a + b)) % 3 for a, b in zip(x, new_vec))
        if y in existing_set and y != x:
            return False

    return True


class GreedyCapSetGenerator:
    def __init__(self, n: int = CAP_N, params: Optional[Dict[str, Any]] = None):
        self.n = n
        self.params: Dict[str, Any] = {
            "balance_weight": 0.6,
            "existing_penalty": 0.1,
            "random_noise": 0.02,
        }
        if params:
            self.params.update(params)

    @staticmethod
    def _try_import_optuna():
        try:
            import optuna  # type: ignore
        except ImportError:
            return None
        return optuna

    def _compute_priorities(
        self,
        candidates: List[Tuple[int, ...]],
        capset: List[Tuple[int, ...]],
        params: Dict[str, Any],
        rng: random.Random,
    ) -> Dict[Tuple[int, ...], float]:
        """
        每轮只调用一次：把 candidates 中所有点的 priority 一次性算完并返回。
        逻辑保持示范级简单：
        - imbalance（点自身）
        - existing_penalty * len(capset)（与已选集合的最弱耦合）
        - 微噪声用于打平（可选）
        """
        priorities: Dict[Tuple[int, ...], float] = {}

        existing_term = params["existing_penalty"] * len(capset)
        noise = params.get("random_noise", 0.0)
        bw = params["balance_weight"]

        for vec in candidates:
            c0 = vec.count(0)
            c1 = vec.count(1)
            c2 = vec.count(2)
            imbalance = abs(c0 - c1) + abs(c1 - c2) + abs(c0 - c2)

            score = -bw * imbalance - existing_term
            if noise:
                score += noise * rng.random()

            priorities[vec] = score

        return priorities

    def generate(
        self,
        params: Optional[Dict[str, Any]] = None,
        rng: Optional[random.Random] = None,
    ) -> List[Tuple[int, ...]]:
        if rng is None:
            rng = random.Random(_RANDOM_SEED)

        active_params = dict(self.params)
        if params:
            active_params.update(params)

        all_vectors = list(itertools.product([0, 1, 2], repeat=self.n))

        capset: List[Tuple[int, ...]] = []
        capset_set: Set[Tuple[int, ...]] = set()

        # 动态贪心：每次选点后，重新计算所有候选点的 priority（但每轮只调用一次计算函数）
        while True:
            # 先收集本轮“可加入”的候选点
            candidates: List[Tuple[int, ...]] = []
            for vec in all_vectors:
                if vec in capset_set:
                    continue
                if can_add(vec, capset, capset_set):
                    candidates.append(vec)

            if not candidates:
                break

            # 每轮只调用一次：批量计算 priority
            priorities = self._compute_priorities(candidates, capset, active_params, rng)

            # 再遍历取最大
            best_vec = None
            best_score = float("-inf")
            for vec in candidates:
                s = priorities[vec]
                if s > best_score:
                    best_score = s
                    best_vec = vec

            if best_vec is None:
                break

            capset.append(best_vec)
            capset_set.add(best_vec)

        return capset

    def tune_with_optuna(
        self,
        max_trials: int = 20,
        timeout: float = 30.0,
    ) -> Tuple[Dict[str, Any], List[Tuple[int, ...]]]:
        optuna = self._try_import_optuna()
        if optuna is None:
            raise RuntimeError("Optuna is not installed. Please run: pip install optuna")

        def objective(trial: Any) -> float:
            sampled = {
                "balance_weight": trial.suggest_float("balance_weight", 0.0, 2.0),
                "existing_penalty": trial.suggest_float("existing_penalty", 0.0, 1.0),
                "random_noise": trial.suggest_float("random_noise", 0.0, 0.05),
            }
            cap = self.generate(params=sampled, rng=random.Random(_RANDOM_SEED))
            return float(len(cap))

        study = optuna.create_study(
            direction="maximize",
            sampler=optuna.samplers.TPESampler(seed=_RANDOM_SEED),
        )
        study.optimize(objective, n_trials=max_trials, timeout=timeout)

        best_params = dict(self.params)
        best_params.update(study.best_params)
        best_capset = self.generate(params=best_params, rng=random.Random(_RANDOM_SEED))
        return best_params, best_capset


def generate_set(n: int) -> List[Tuple[int, ...]]:
    generator = GreedyCapSetGenerator(n=n)
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
    return tuned_capset


```
Key features: Performs well on combined_score (0.0000), Performs well on error (generator failure), Performs well on error_detail (Optuna is not installed. Please run: pip install optuna), Performs well on eval_time_seconds (0.0879), Performs well on dimension (8.0000), Performs well on traceback (Traceback (most recent call last):
  File "C:\Users\admin\AppData\Local\Temp\openevolve_gen_runner_gcnwiz_q.py", line 18, in <module>
    res = mod.generate_set(arg)
  File "C:\Users\admin\AppData\Local\Temp	mpuh9yf4pn.py", line 163, in generate_set
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
  File "C:\Users\admin\AppData\Local\Temp	mpuh9yf4pn.py", line 138, in tune_with_optuna
    raise RuntimeError("Optuna is not installed. Please run: pip install optuna")
RuntimeError: Optuna is not installed. Please run: pip install optuna
), Performs well on artifact_path (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020451Z_307e6521_tmpuh9yf4pn.py), Performs well on generator_stdout_artifact (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020452Z_d9c70760_generator_stdout.json), Performs well on generator_stderr_artifact (C:\Users\admin\AppData\Local\Temp\openevolve_output\artifacts\20251226T020452Z_d9c70760_generator_stderr.txt)

## Inspiration Programs

These programs represent diverse approaches and creative solutions that may inspire new ideas:

### Inspiration 1 (Score: 265.0000, Type: High-Performer)
```python
import itertools
import random
from typing import Tuple, List, Optional, Dict, Any, Set

CAP_N = 8
_RANDOM_SEED = 42


def can_add(
    new_vec: Tuple[int, ...],
    existing_list: List[Tuple[int, ...]],
    existing_set: Optional[set] = None,
) -> bool:
    if existing_set is None:
        existing_set = set(existing_list)

    if new_vec in existing_set:
        return False

    for x in existing_list:
        y = tuple((-(a + b)) % 3 for a, b in zip(x, new_vec))
        if y in existing_set and y != x:
            return False

    return True


class GreedyCapSetGenerator:
    def __init__(self, n: int = CAP_N, params: Optional[Dict[str, Any]] = None):
        self.n = n
        self.params: Dict[str, Any] = {
            "balance_weight": 0.6,
            "existing_penalty": 0.1,
            "random_noise": 0.02,
            "diversity_weight": 0.3,
        }
        if params:
            self.params.update(params)

    @staticmethod
    def _try_import_optuna():
        try:
            import optuna  # type: ignore
        except ImportError:
            return None
        return optuna

    def _compute_priorities(
        self,
        candidates: List[Tuple[int, ...]],
        capset: List[Tuple[int, ...]],
        params: Dict[str, Any],
        rng: random.Random,
    ) -> Dict[Tuple[int, ...], float]:
        """
        每轮只调用一次：把 candidates 中所有点的 priority 一次性算完并返回。
        逻辑保持示范级简单：
        - imbalance（点自身）
        - existing_penalty * len(capset)（与已选集合的最弱耦合）
        - 微噪声用于打平（可选）
        """
        priorities: Dict[Tuple[int, ...], float] = {}

        existing_term = params["existing_penalty"] * len(capset)
        noise = params.get("random_noise", 0.0)
        bw = params["balance_weight"]

        for vec in candidates:
            c0 = vec.count(0)
            c1 = vec.count(1)
            c2 = vec.count(2)
            imbalance = abs(c0 - c1) + abs(c1 - c2) + abs(c0 - c2)

            score = -bw * imbalance - existing_term
            if noise:
                score += noise * rng.random()

            priorities[vec] = score

        return priorities

    def generate(
        self,
        params: Optional[Dict[str, Any]] = None,
        rng: Optional[random.Random] = None,
    ) -> List[Tuple[int, ...]]:
        if rng is None:
            rng = random.Random(_RANDOM_SEED)

        active_params = dict(self.params)
        if params:
            active_params.update(params)

        all_vectors = list(itertools.product([0, 1, 2], repeat=self.n))

        capset: List[Tuple[int, ...]] = []
        capset_set: Set[Tuple[int, ...]] = set()

        # 动态贪心：每次选点后，重新计算所有候选点的 priority（但每轮只调用一次计算函数）
        while True:
            # 先收集本轮“可加入”的候选点
            candidates: List[Tuple[int, ...]] = []
            for vec in all_vectors:
                if vec in capset_set:
                    continue
                if can_add(vec, capset, capset_set):
                    candidates.append(vec)

            if not candidates:
                break

            # 每轮只调用一次：批量计算 priority
            priorities = self._compute_priorities(candidates, capset, active_params, rng)

            # 再遍历取最大
            best_vec = None
            best_score = float("-inf")
            for vec in candidates:
                s = priorities[vec]
                if s > best_score:
                    best_score = s
                    best_vec = vec

            if best_vec is None:
                break

            capset.append(best_vec)
            capset_set.add(best_vec)

        return capset

    def tune_with_optuna(
        self,
        max_trials: int = 20,
        timeout: float = 30.0,
    ) -> Tuple[Dict[str, Any], List[Tuple[int, ...]]]:
        optuna = self._try_import_optuna()
        if optuna is None:
            raise RuntimeError("Optuna is not installed. Please run: pip install optuna")

        def objective(trial: Any) -> float:
            sampled = {
                "balance_weight": trial.suggest_float("balance_weight", 0.0, 2.0),
                "existing_penalty": trial.suggest_float("existing_penalty", 0.0, 1.0),
                "random_noise": trial.suggest_float("random_noise", 0.0, 0.05),
            }
            cap = self.generate(params=sampled, rng=random.Random(_RANDOM_SEED))
            return float(len(cap))

        study = optuna.create_study(
            direction="maximize",
            sampler=optuna.samplers.TPESampler(seed=_RANDOM_SEED),
        )
        study.optimize(objective, n_trials=max_trials, timeout=timeout)

        best_params = dict(self.params)
        best_params.update(study.best_params)
        best_capset = self.generate(params=best_params, rng=random.Random(_RANDOM_SEED))
        return best_params, best_capset


def generate_set(n: int) -> List[Tuple[int, ...]]:
    # Handle Optuna import gracefully
    optuna = GreedyCapSetGenerator._try_import_optuna()
    if optuna is None:
        # Fallback to default parameters if Optuna is not available
        generator = GreedyCapSetGenerator(n=n)
        return generator.generate()
    
    generator = GreedyCapSetGenerator(n=n)
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
    return tuned_capset


```
Unique approach: Excellent combined_score (265.000), Excellent size (265.000), Excellent valid (1.000)

# Current Program
```python
import itertools
import random
from typing import Tuple, List, Optional, Dict, Any, Set

CAP_N = 6
_RANDOM_SEED = 42


def can_add(
    new_vec: Tuple[int, ...],
    existing_list: List[Tuple[int, ...]],
    existing_set: Optional[set] = None,
) -> bool:
    if existing_set is None:
        existing_set = set(existing_list)

    if new_vec in existing_set:
        return False

    for x in existing_list:
        y = tuple((-(a + b)) % 3 for a, b in zip(x, new_vec))
        if y in existing_set and y != x:
            return False

    return True


class GreedyCapSetGenerator:
    def __init__(self, n: int = CAP_N, params: Optional[Dict[str, Any]] = None):
        self.n = n
        self.params: Dict[str, Any] = {
            "balance_weight": 0.6,
            "existing_penalty": 0.1,
            "random_noise": 0.02,
        }
        if params:
            self.params.update(params)

    @staticmethod
    def _try_import_optuna():
        try:
            import optuna  # type: ignore
        except ImportError:
            return None
        return optuna

    def _compute_priorities(
        self,
        candidates: List[Tuple[int, ...]],
        capset: List[Tuple[int, ...]],
        params: Dict[str, Any],
        rng: random.Random,
    ) -> Dict[Tuple[int, ...], float]:
        """
        每轮只调用一次：把 candidates 中所有点的 priority 一次性算完并返回。
        逻辑保持示范级简单：
        - imbalance（点自身）
        - existing_penalty * len(capset)（与已选集合的最弱耦合）
        - 微噪声用于打平（可选）
        """
        priorities: Dict[Tuple[int, ...], float] = {}

        existing_term = params["existing_penalty"] * len(capset)
        noise = params.get("random_noise", 0.0)
        bw = params["balance_weight"]

        for vec in candidates:
            c0 = vec.count(0)
            c1 = vec.count(1)
            c2 = vec.count(2)
            imbalance = abs(c0 - c1) + abs(c1 - c2) + abs(c0 - c2)

            score = -bw * imbalance - existing_term
            if noise:
                score += noise * rng.random()

            priorities[vec] = score

        return priorities

    def generate(
        self,
        params: Optional[Dict[str, Any]] = None,
        rng: Optional[random.Random] = None,
    ) -> List[Tuple[int, ...]]:
        if rng is None:
            rng = random.Random(_RANDOM_SEED)

        active_params = dict(self.params)
        if params:
            active_params.update(params)

        all_vectors = list(itertools.product([0, 1, 2], repeat=self.n))

        capset: List[Tuple[int, ...]] = []
        capset_set: Set[Tuple[int, ...]] = set()

        # 动态贪心：每次选点后，重新计算所有候选点的 priority（但每轮只调用一次计算函数）
        while True:
            # 先收集本轮“可加入”的候选点
            candidates: List[Tuple[int, ...]] = []
            for vec in all_vectors:
                if vec in capset_set:
                    continue
                if can_add(vec, capset, capset_set):
                    candidates.append(vec)

            if not candidates:
                break

            # 每轮只调用一次：批量计算 priority
            priorities = self._compute_priorities(candidates, capset, active_params, rng)

            # 再遍历取最大
            best_vec = None
            best_score = float("-inf")
            for vec in candidates:
                s = priorities[vec]
                if s > best_score:
                    best_score = s
                    best_vec = vec

            if best_vec is None:
                break

            capset.append(best_vec)
            capset_set.add(best_vec)

        return capset

    def tune_with_optuna(
        self,
        max_trials: int = 20,
        timeout: float = 30.0,
    ) -> Tuple[Dict[str, Any], List[Tuple[int, ...]]]:
        optuna = self._try_import_optuna()
        if optuna is None:
            raise RuntimeError("Optuna is not installed. Please run: pip install optuna")

        def objective(trial: Any) -> float:
            sampled = {
                "balance_weight": trial.suggest_float("balance_weight", 0.0, 2.0),
                "existing_penalty": trial.suggest_float("existing_penalty", 0.0, 1.0),
                "random_noise": trial.suggest_float("random_noise", 0.0, 0.05),
            }
            cap = self.generate(params=sampled, rng=random.Random(_RANDOM_SEED))
            return float(len(cap))

        study = optuna.create_study(
            direction="maximize",
            sampler=optuna.samplers.TPESampler(seed=_RANDOM_SEED),
        )
        study.optimize(objective, n_trials=max_trials, timeout=timeout)

        best_params = dict(self.params)
        best_params.update(study.best_params)
        best_capset = self.generate(params=best_params, rng=random.Random(_RANDOM_SEED))
        return best_params, best_capset


def generate_set(n: int) -> List[Tuple[int, ...]]:
    generator = GreedyCapSetGenerator(n=CAP_N)
    best_params, tuned_capset = generator.tune_with_optuna(max_trials=100, timeout=30.0)
    return tuned_capset


```

# Required Output
Suggest targeted improvements using the exact SEARCH/REPLACE diff format:

<<<<<<< SEARCH
# Exact code from the current program to replace (must match exactly)
=======
# New code
>>>>>>> REPLACE

Example:
<<<<<<< SEARCH
for i in range(m):
    for j in range(p):
        for k in range(n):
            C[i, j] += A[i, k] * B[k, j]
=======
for i in range(m):
    for k in range(n):
        for j in range(p):
            C[i, j] += A[i, k] * B[k, j]
>>>>>>> REPLACE

Rules:
- SEARCH text must match the current program exactly; include full context needed for replacement.
- You may include multiple diff blocks.
- Preserve the greedy priority-driven structure and the single-strategy constraint while improving scoring, determinism, and Optuna tuning.
- Do not rewrite the entire file; focus on minimal, high-impact changes.
- Briefly explain why each change helps before or after the diff blocks.
