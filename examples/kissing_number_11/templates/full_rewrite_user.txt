## Context (for reference only)

Performance metrics, prior attempts, and artifacts are provided for reference only.
Do NOT explain them. Do NOT restate them.

{metrics}
{improvement_areas}
{artifacts}
{evolution_history}

---

## Current Program (reference only)

BEGIN_CURRENT_PROGRAM
{current_program}
END_CURRENT_PROGRAM

---

## TASK (DO EXACTLY THIS)

Return a COMPLETE replacement of the program source file.

The program MUST define:

def get_C():

and MUST return a NON-EMPTY Python list of points.

Each point:
- is a list or tuple
- has EXACTLY 11 coordinates
- ALL coordinates are EXACT INTEGERS

---

## OBJECTIVE (ABSOLUTE PRIORITY)

Maximize |C|, the number of points returned by get_C().

If ANY constraint is violated, the solution is INVALID.
A smaller VALID set is ALWAYS better than a larger INVALID one.

---

## HARD CONSTRAINTS (NO EXCEPTIONS)

C0: Integer-only geometry  
C1: Origin exclusion  
C2: Global distance domination  

(Definitions unchanged; see previous specification.)

---

## CRITICAL ALGORITHMIC REQUIREMENT (MANDATORY)

The set C MUST be produced by an EXPLICIT ALGORITHMIC SEARCH
or OPTIMIZATION PROCESS.

Specifically:

- C must be the RESULT of an algorithm that incrementally
  constructs, tests, and accepts/rejects candidate points.
- The algorithm MUST include:
  - candidate generation
  - explicit distance checking against existing points
  - conditional acceptance or rejection

The following are STRONGLY DISCOURAGED and should be AVOIDED:

- Direct closed-form constructions
- Purely combinatorial enumeration of coordinate patterns
- Hard-coded lists of points
- Simple symbolic rules of the form
  “for all i,j assign ±M to coordinates”

If the entire set C can be described succinctly
without running a search or validation loop,
the solution is considered LOW QUALITY.

Prefer smaller VALID sets produced by a genuine algorithm
over larger sets produced by direct construction.

---

## STRATEGY GUIDANCE

Think in terms of:
- greedy packing
- randomized search with rejection
- iterative augmentation
- local improvement under constraints

The algorithm does NOT need to be optimal,
but it MUST genuinely SEARCH.

Large integer magnitudes are useful because they allow finer-grained
allocation of squared differences under integer-only constraints,
not because of scaling or normalization.

### SOTA HINTS (LEVERAGE KNOWN STRUCTURE)

* A known high-quality set has **593 points** with:
  - all norm R approximates 1e13 (all points nearly in a single sphere)
  - min_pairwise approximates R (tight kissing condition)
  - frequent angles: 60, 90, 120 degrees
  - partial sign symmetry and near-zero centroid

* Practical guidance:
  - **Reuse or subset** points from the known set when unsure; even a large subset is valid.
  - Keep norms roughly uniform (single radius) to satisfy the global constraint cleanly.
  - Mix signs to keep centroid near the origin; avoid all-positive vectors.
  - Prefer larger coordinates (e.g., around 1e12-1e13) to keep distances well above the threshold.
  - Aim for a **large |C|** (e.g., larger than 100 if possible); avoid returning tiny sets unless necessary for validity.

---

## OUTPUT FORMAT (STRICT)

Your entire response MUST be EXACTLY ONE Python fenced code block.

- The response MUST start with ```python
- The response MUST end with ```
- NO text outside the code block.
- The code block MUST define get_C() at top level.

Now output the replacement program.
